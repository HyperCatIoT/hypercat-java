package org.openIOT;

import java.io.IOException;
import java.util.Iterator;

import org.codehaus.jackson.JsonGenerationException;
import org.codehaus.jackson.JsonParseException;
import org.codehaus.jackson.map.JsonMappingException;
import org.codehaus.jackson.map.ObjectMapper;
import org.junit.Assert;
import org.junit.Test;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


/* The basic Hypercat object.  In the composite pattern, this is the only object that exists (ala the Lambda world), and is 'extended'
 * for leaf/resource objects by removing child objects.  Currently breaking this by subclassing Resource  
 * 
 * still need to finalize rules for traversing the graph of hypercats, and how much needs to be in-memory at any given time
 * 
 */


public class HypercatUnitTests {
    
    private Logger log = LoggerFactory.getLogger(HypercatUnitTests.class);
    
    /*
     * tests:  
     * 0) creation of a basic minimum-spec hypercat
     * 1) creation of a hypercat populated with multiple Relations (some identical)
     * 2) creation of a hypercat populated with Resource items (some of which are Hypercats)
     * 3) adding duplicate resource item to a hypercat fails
     * 4) Create hypercat from JSON string
     * 5) Creation of a hypercat from an invalid JSON string fails
     * 6) Output a hypercat to a flat JSON string
     * 7) Output a hypercat to a pretty JSON string
     * 
     */
    
    @Test
    public void testBasicHypercat(){     
        // test basic Hypercat creation
        Hypercat hc = new Hypercat("test-empty-catalogue");
        Relation returned = hc.findFirstRelation("urn:X-tsbiot:rels:hasDescription:en");        
        Assert.assertEquals("urn:X-tsbiot:rels:hasDescription:en", returned.rel );  
        Assert.assertEquals("test-empty-catalogue", returned.val );       
    }  
    
    @Test
    public void testPopulatedHypercat(){
        
        Hypercat hc = new Hypercat("test-populated-catalogue");
        Relation returned = hc.findFirstRelation("urn:X-tsbiot:rels:hasDescription:en");
        Assert.assertEquals("urn:X-tsbiot:rels:hasDescription:en", returned.rel );  
        Assert.assertEquals("test-populated-catalogue", returned.val );   
        
        
        //add another hypercat to the items collection of the firsts hypercat
        Hypercat hc2 = new Hypercat("child hypercat with manually-set href");
       // hc2.setHref("manual-UUID");
        hc.addItem(hc2,"manual-UUID");     
        //test added item is on list, and can be retrieved from it
        Assert.assertEquals(1, hc.getItems().size() ); 
        Hypercat hc3 = (Hypercat) hc.getItems().get("manual-UUID");
        log.info(" hc3 HC ="+hc3.toString());
        Relation rel2 =  (Relation) hc3.findFirstRelation("urn:X-tsbiot:rels:hasDescription:en");
        log.info("rel metatdata from hc3="+rel2.val);
        Assert.assertEquals("child hypercat with manually-set href", rel2.getVal());
        
        //add another hypercat to hc's items collection, but this time rely on an autogenerated href
        Hypercat hc4 = new Hypercat("child hypercat with automatically-set href");
        String autoHref = hc.addItem(hc4);     
        //test added item is on list, and can be retrieved from it
        Assert.assertEquals(2, hc.getItems().size() );
        
        Hypercat hc5 = (Hypercat) hc.getItems().get(autoHref);
        log.info(" hc5 HC ="+hc5.toString());
        Relation rel3 =  (Relation) hc5.findFirstRelation("urn:X-tsbiot:rels:hasDescription:en");
        log.info("rel metatdata from hc5="+rel3.val);
        //Assert.assertEquals(autoHref, ( (Hypercat) (hc.getItems().get(autoHref))).getHref() ); 
        Assert.assertEquals("child hypercat with automatically-set href", rel3.getVal());
                  
        //test that adding the same hypercat again fails
        String localUID = hc.addItem(hc4,autoHref);        
        Assert.assertEquals("itemExists", localUID); 
        
        //add an Resource to hc           
        Resource item = new Resource("itemHref","added Resource","text");
        hc.addItem(item);
              
       //and retrieve it            
        Resource retrievedItem = (Resource) hc.getItems().get("itemHref");
        Assert.assertEquals("itemHref",retrievedItem.getHref() );        
        
        //test that adding the same item again fails
        localUID = hc.addItem(item);        
        Assert.assertEquals("itemExists", localUID );         
    }
    
    
    @Test
    public void testJsonFunctions() {
        Hypercat hc6 = null;
        //test construct-hypercat-from-JSON-string
        String jsonString = "{ \"item-metadata\": [{  \"rel\": \"urn:X-tsbiot:rels:isContentType\",  \"val\": \"application/vnd.tsbiot.catalogue+json\"  }, {\"rel\": \"urn:X-tsbiot:rels:hasDescription:en\",  \"val\": \"Test Description\"  } ],"
                          + " \"items\": ["
                          + "{  \"href\": \"http://FIXME\",  \"i-object-metadata\": [  { \"rel\": \"urn:X-tsbiot:rels:isContentType\",  \"val\": \"application/vnd.tsbiot.catalogue+json\"  },{ \"rel\": \"urn:X-tsbiot:rels:hasDescription:en\", \"val\": \"resource1\" }  ] },"
                          + "{  \"href\": \"http://FIXME2\", \"i-object-metadata\": [  { \"rel\": \"urn:X-tsbiot:rels:isContentType\",  \"val\": \"application/vnd.tsbiot.catalogue+json\"  },{ \"rel\": \"urn:X-tsbiot:rels:hasDescription:en\", \"val\": \"resource2\" }  ] } "
                          + "] }";
 
        log.info("about to create Hypercat object by parsing : "+jsonString); 
        
        try {
                hc6 = new Hypercat(jsonString,true);
                } catch (JsonParseException e) {
                     e.printStackTrace();
                } catch (JsonMappingException e) {
                    e.printStackTrace();
                } catch (IOException e) {
                   e.printStackTrace();
        }
  
        log.info(" itemmetadata = ", hc6.getItemMetadata().toString());    
   //     log.info(" in HC constructor - created hypercat from JSON with description{} created with value {}",hc6.getItemMetadata().get("urn:X-tsbiot:rels:hasDescription:en") );      

        
        Relation rel = (Relation) hc6.findFirstRelation("urn:X-tsbiot:rels:hasDescription:en");
        Assert.assertEquals("Test Description", rel.val);
   
  log.info("itemslist ="+ hc6.getItems().toString());
  
  log.info("keyset="+hc6.getItems().keySet().toString());
  
  String key = "\"http://FIXME2\"";
  log.info("items list has size= {}",hc6.getItems().size());
   
   Object itout =  (Object) hc6.getItems().get(key);
   

   
   log.info("itemobject class for key={} is {} ",key,itout.getClass());
   
  // log.info("itout href={}",itout.getHref());
   
   Resource hydratedItem = (Resource) itout;
   String output = "";
   log.info("metadata aray="+hydratedItem.getIObjectMetadata().toString());
 
   log.info("hydrated item metadata 1 is "+output);
   
    log.info("retrieved item = "+  prettyPrint(hydratedItem) );
   

   log.info("serialised object = {}", hc6.toPrettyJson());
   
   
   
    
    }

    String prettyPrint(Object o){
        String output = "NO JSON";
        ObjectMapper mapper = new ObjectMapper();
        //mapper.setVisibility(JsonMethod.FIELD, Visibility.ANY);
       // ObjectWriter typedWriter = mapper.writerWithType(mapper.getTypeFactory().constructCollectionType(Resource.class);
       
        try {
            output = mapper.writerWithDefaultPrettyPrinter().writeValueAsString(o);
        } catch (JsonGenerationException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (JsonMappingException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
        return output;
 }
  
   
    // test print as JSON()
    // test prettyprint as JSON()
    
    //test construct-from-file
    
    
    //test search-catalogue-and-return-cat
    
    


}
